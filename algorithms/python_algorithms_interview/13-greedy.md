# 그리디 알고리즘

- 그리디 알고리즘으 글로벌 최적을 찾기 위해 각 단계에서 로컬 취적의 선택을 하는 휴리스틱 문제 해결 알고리즘이다.
- 그리디 알고리즘이 잘 작동하는 문제들은 탐욕 선택 속성을 갖고 있는 최적 부분 구조인 문제들이다.
- __탐욕 선택 속성__이란 앞의 선택이 이후 선택에 영향을 주지 않는 것을 말한다.
- __최적 부분 구조__란 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 말한다.

- 이 두가지 조건을 만족하지 않더라도 그리디 알고리즘은 정답을 근사하게 찾는 용도로 활용할 수 있으며 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.
- 다이나믹 프로그래밍이 하위 문제에 대한 최적의 솔루션을 찾은 다음 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션에 대한 선택을 한다면 이에 반해 그리디 알고리즘은 각 단계마다 로컬 최적해를 찾는 문제다.



__배낭 문제__

- 배낭에 담을 수 있는 무게의 최댓값이 정해져 있고 각각 짐의 가치와 무게가 있는 짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제다.
- 배낭 문제는 짐을 쪼갤 수 있는 분할 가능 배낭 문제(그리디 알고리즘으로 해결)과 짐을 쪼갤 수 없는 경우인 0-1 배낭문제(다이나믹 프로그래밍으로 해결)로 나뉜다.
- 분할 가능 배낭 문제의 경우 단가가 높은 짐부터 차례대로 채워나가면 된다. 짐을 (가격, 무게)의 튜플 리스트로 정의하고 단가를 계산해 역순으로 정렬한다. 그 후 단가 순으로 그리디 알고리즘으로 계산하면 된다.

```python
def solution(cargo):
    capacity = 15
    pack = []
    # 단가 계산 역순 정렬
    for c in cargo:
        pack.append((c[0] / c[1], c[0], c[1]))
    pack.sort(reverse=True)
    
    # 단가 순 그리디 계산
    total_value = 0
    for p in pack:
        if capacity - p[2] >= 0:
            capacity -= p[2]
            total_value += p[1]
        else:
            fraction = capacity / p[2]
            total_value += p[1] * fraction
            break
    
    return total_value
```



__동전 바꾸기 문제__

- 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀 수 있다.
- 그러나 만약 다른 나라에 갔더니 80원짜리 동전이 더 있다고 하면 그리디하게 풀 수 없다. 160원을 거슬러줄 때 80원짜리 2개가 정답이지만 그리디 알고리즘은 100원부터 선택하게 될 것이기 때문이다.



### 주식을 사고팔기 가장 좋은 시점 2

- 여러 번의 거래로 낼 수 있는 최대 이익을 산출하라.

> __예제__
>
> - 입력: [7, 1, 5, 3, 6, 4]
> - 출력: 7
> - 설명: 1일 때 사서 5일 때 팔아 4의 이익을 얻고, 3일 때 사서 6일 때 팔아 3의 이익을 얻는다. 둘을 합하면 7이 된다.



__풀이 1. 그리디 알고리즘__

- 내리기 전에 팔고 오르기 전에 사는 식으로 몇번이든 사고팔고를 반복한다.
- 다음번 값이 현재보다 오르는 경우에 항상 이익을 취하는 형태로 매번 단계마다 이익을 취하는 탐욕 구조로 구현할 수 있다.

```python
def solution(prices):
    result = 0
    # 값이 오르는 경우 매번 그리디 계산
    for i in range(len(prices) - 1):
        if prices[i + 1] > prices[i]:
            result += prices[i + 1] - prices[i]
    return result
```



__풀이 2. 파이썬다운 방식__

```python
def solution(prices):
    # 0보다 크면 무조건 합산
    return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))
```



### 키에 따른 대기열 재구성

- 여러 명의 사람들이 줄을 서 있다. 각각의 사람은 (h, k)의 두 정수 쌍을 갖는데, h는 그 사람의 키, k는 앞에 줄 서 있는 사람들 중 자신의 키 이상인 사람들에 수를 뜻한다. 이 값이 올바르도록 줄을 재정렬하는 알고리즘을 작성하라.

> __예제__
>
> - 입력: [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]
> - 출력: [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]



__풀이 1. 우선순위 큐 이용__

- 우선순위 큐는 그때그때의 최소 또는 최댓값을 추출하기 때문에 그리디에 어울리는 대표적인 자료구조라 할 수 있다.
- 첫번째 값이 큰 순서대로 추출되는 최대 힙 형태로 풀이할 수 있고 두 번째 값은 삽입되는 인덱스로 활용할 수 있다.

```python
def solution(people):
    heap = []
    # 키 역순, 인덱스 삽입
    for person in people:
        heapq.heappush(heap, (-person[0], person[1]))
    
    result = []
    # 키 역순, 인덱스 추출
    while heap:
        person = heapq.heappop(heap)
        result.insert(person[1], [-person[0], person[1]])
        
    return result
```





### 태스크 스케줄러

- A에서 Z로 표현된 태스크가 있다. 각 간격마다 CPU는 한 번의 태스크만 실행 할 수 있고, n번의 간격 내에는 동일한 태스크를 실행할 수 없다. 더 이상 태스크를 실행할 수 없는 경우 아이들 상태가 된다. 모든 태스크를 실행하기 위한 최소 간격을 출력하라.

> __예제__
>
> - 입력: task = ["A", "A", "A". "B". "B". "B"], n = 2
> - 출력: 8



__풀이 1. 우선순위 큐 사용__

- 이 문제 역시 우선순위 큐를 이용해 그리디하게 풀 수 있는 문제지만 아이템을 추출한 이후에는 매번 아이템 개수를 업데이트해줘야 한다. 간결한 방식을 풀어보기 위해 Counter 모듈을 사용해 코드를 구현해보자.

```python
def solution(tasks, n):
    counter = collections.Counter(tasks)
    result = 0
    
    while True:
        sub_count = 0
    	for task, _ in counter.most_common(n + 1):
            sub_count += 1
            result += 1
            
            counter.subtract(task) # 한개 씩 개수 줄이기
            # 0 이하인 아이템을 목록에서 완전히 제거
            counter += collections.Counter()
            
        if not counter:
            break
        
        result += n - sub_count + 1
    
    return result
```



### 주유소

- 원형으로 경로가 연결된 주유소 목록이 있다. 각 주유소는 gas[i]만큼의 기름을 갖고 있으며, 다음 주유소로 이동하는 데 cost[i]가 필요하다. 기름이 부족하면 이동할 수 없다고 할 때 모든 주유소를 방문할 수 있는 출발점의 인덱스를 출력하라.
- 출발점이 존재하지 않는 경우 -1을 출력하라.

> __예제__
>
> - 입력: gas = [1, 2, 3, 4, 5], cost = [3, 4, 5, 1, 2]
> - 출력: 3



__풀이 1. 한 번 방문__

- 전체 기름의 양이 전체 비용보다 클 경우 반드시 전체를 방문할 수 있는 출발점이 존재한다. 이 문제에는 출발점이 유일하다는 제약이 있으므로 반드시 한군데만 존재한다.
- 이 문제는 한 번 이상은 반드시 성립되지 않는 지점이 존재한다. 성립되지 않는 지점이 있을 때 그 앞은 전부 출발점이 될 수 없다.

```python
def solution(gas, cost):
    # 모든 주유소 방문 가능 여부 판별
    if sum(gas) < sum(cost):
        return -1
    
    start, fuel = 0, 0
    for i in range(len(gas)):
        # 출발이 안되는 지점 판별
        if gas[i] + fuel < cost[i]:
            start = i + 1
            fuel = 0
        else:
            fuel += gas[i] - cost[i]
    return start
```



### 쿠키 부여

- 아이들에게 1개씩 쿠키를 나눠줘야 한다. 각 아이마다 그리드 팩터를 가지고 있으며 이는 아이가 만족하는 최소 쿠키의 크기를 말한다. 각 쿠키는 크기를 갖고 있으며 크기가 그리드 팩터보다 커야 아이가 만족하며 쿠키를 받는다. 최대 몇 명의 아이들에게 쿠키를 줄 수 있는 지 출력하라.

> __예제__
>
> - 입력: [1, 2, 3], [1, 1]
> - 출력: 1
> - 설명: 두 번째 아이부터는 크기 2 이상의 쿠키가 필요하지만, 갖고 있는 최대 크기는 1이기 때문에 1명의 아이에게만 줄 수 있다.



__풀이 1. 그리디 알고리즘__

```python
def solution(g, s):
    g.sort()
    s.sort()
    
    child_i = cookie_j = 0
    # 만족하지 못할 때까지 그리디 진행
    while child_i < len(g) and cookie_j < len(s):
        if s[cookie_j] >= g[child_i]:
            child_i += 1
        cookie_j += 1
        
    return child_i
```

