# 파이썬 문법

1. 인덴트
- 공백 4칸 들여쓰기가 원칙
- 첫줄에 파라미터가 있다면 파라미터가 시작되는 곳에 인덴트를 맞춘다
	foo = long_function(var_one, var_two,
                                         var_three, var_four)

- 첫줄에 파라미터가 없다면 공백 4칸을 한 번 더 추가해 다른행과 구분되게 한다.
	foo = long_function_name(
              var_one, var_two,
	var_three, var_four)

- 파이참의 reformat code를 사용하면 자동으로 코드를 PEP8 기준으로 맞춰준다.

2. 네이밍 컨벤션

- 단어를 밑줄(_)로 구분하는 스네이크 케이스를 따른다.

3. 타입 힌트

- 다음과 같은 형태로 타입을 선언할 수 있다.
	a : str = “1”
	b : int = 1

- 함수의 인수와 리턴 값의 타입 힌트를 다음과 같이 추가할 수 있다.
	def fn(a : int) -> bool:

-  mypy를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있다.

4. 리스트 컴프리헨션

- 파이썬은 map, filter와 같은 함수형 기능을 지원하며 다음과 같은 람다 표현식도 지원한다
	list(map(lambda x: x + 10, [1, 2, 3]))

- 리스트 컴프리헨션은 리스트를 기반으로 새로운 리스트를 만들어내는 구문이다.
- map이나 filter를 사용하는 것보다 가독성이 훨씬 높다.
	[n * 2 for n in range(1, 10 + 1) if n % 2 == 1]  # (홀수인 경우 2를 곱해 출력하라는 리스트 컴프레헨션)

- 딕셔너리 역시 컴프레헨션이 가능하다
	a = (key:value for key, value in original.items()}

- 무리하게 복잡하게 작성할 경우 가독성을 떨어트리므로 적절히 사용하는게 중요하다. 대체로 표현식은 2개를 넘지 않아야 한다.

5. 제네레이터

- 루프의 반복(iteration) 동작을 제어할 수 있는 루틴 형태를 말한다.
- return 대신 yield 구문을 사용하면 제네레이터를 리턴할 수 있다. 중간값을 리턴한 다음 함수가 종료되지 않고 계속 실행된다
	def get_natural_number():
		n = 0
		while True:
			n += 1
		yield n
- 다음 값을 생성하려면 next()로 추출하면 된다.
- 여러 타입의 값을 하나의 함수에서 생성하는 것도 가능하다.
	def generator():
		yield 1
		yield ‘string’
		yield True

6. range

- range()는 제네레이터 방식을 활용하는 대표적인 함수다.
- range()는 제네레이터를 생성하므로 리스트보다 메모리를 절약할 수 있다.

7. enumerate

- enumerate는 여러가지 자료형을 인덱스를 포함한 enumerate 객체로 리턴한다.

8. // 나눗셈 연산자

- // 연산자는 몫을 구하는 연산자 역할을 한다. 5 // 3은 int(5 / 3)과 동일하다.
- 나머지를 구하는 연산자는 %이다.

9. print

- 코딩테스트에서 디버깅을 할 때 가장 자주 쓰는 명령은 print이다.
- 가장 쉽게 값을 출력하는 방법은 콤마로 구분하는 것이다. 이 경우 한 칸 공백이 디폴트로 설정되어 있다.
- 다음과 같이 sep 파라미터로 구분자를 콤마로 지정해줄 수도 있다
	print(‘A1’, ‘B1’, sep=‘,’)

- end 파라미터를 공백으로 처리하여 줄바꿈을 하지 않도록 제한할 수 있다.
	print(‘aa’, ‘bb’, end=‘ ‘)

- 리스트를 출력할 때는 join()으로 묶어서 처리한다.
	a = [‘a’, ‘b’]
	print(‘ ‘.join(a))

- f-string은 변수를 뒤에 별도로 부여할 필요없어 편리하고 간결하며 속도도 빠르다
	print(f’{idx + 1} : {fruit}’)

10. pass
- pass는 널 연산으로 아무것도 하지 않는 기능이다.
- pass는 목업 인터페이스부터 구현한 다음에 추후 구현을 진행할 수 있게 한다.

11. locals
-  로컬에 선언된 모든 변수를 조회할 수 있는 명령이다. 디버깅에 많은 도움이 된다.
- pprint로 출력하게 되면 보기 좋게 줄바꿈 처리를 해주기 때문에 가독성이 높다
	import pprint
	pprint.pprint(locals())


# 코딩 스타일

1. 변수명과 주석

-  자세한 변수명과 상세한 주석을 사용하는 것이 좋다.

2. 리스트 컴프리헨션

- 리스트 컴프리헨션으 ㄴ대부분 한 줄로 적게되는 경우가 많은데 역할별로 줄 구분을 하면 가독성이 높아지고 이해하기 쉬워진다.

	strl = [
	str1[i:i + 2].lower() for i in range(len(str1) - 1)
	if re.findall(‘[a-z]{2}’, str1[i:i +2].lower())
	]

3. 구글 파이썬 스타일 가이드

- 함수의 기본값으로 가변 객체를 사용하지 않아야 한다. 함수가 객체를 수정하면 기본값이 변경되기 때문이다.
	def foo(a, b=[]):

- 대신 다음과 같이 불변 객체를 사용한다.
	def foo(a, b=None)

- True, False를 판별할 때는 암시적인 방법을 사용하는 편이 간결하고 가독성이 높다.
	if len(users) == 0 # (x)
	if not users (o)

- 다만 정수를 처리할 때에는 암시적인 방법보단 정수값을 직접 비교하는 것이 좋다.
	if not i % 10: # (x)
	if i % 10 == 0 # (o)

- 최대 줄 길이는 80자로 한다.